import React, { useState, useEffect, useCallback } from 'react';
import { GoogleGenAI, Type } from '@google/genai';

// Auth and Layout
import { useAuth } from './components/AuthContext';
import LoggedInLayout from './components/LoggedInLayout';
import LoginModal from './components/LoginModal';
import OnboardingModal from './components/onboarding/OnboardingModal';
import SearchModal from './components/SearchModal';

// Pages
import HomePage from './components/HomePage';
import LandingPage from './components/LandingPage';
import HirerLandingPage from './components/HirerLandingPage';
import ExplorePage from './components/ExplorePage';
import JobPage from './components/JobPage';
import ApplyPage from './components/ApplyPage';
import DeviceCheckPage from './components/DeviceCheckPage';
import InterviewScreen from './components/InterviewScreen';
import InterviewResultPage from './components/InterviewResultPage';
import CandidateDashboardPage from './components/CandidateDashboardPage';
import HirerDashboardPage from './components/HirerDashboardPage';
import ProfilePage from './components/ProfilePage';
import EarningsPage from './components/EarningsPage';
import ReferralsPage from './components/ReferralsPage';
import DomainExpertPage from './components/DomainExpertPage';
import SettingsPage from './components/SettingsPage';
import AdminPage from './components/AdminPage';


// Data and Types
import { JOBS, SYSTEM_PROMPT_TEMPLATE } from './constants';
import { AppRoute, Job, TranscriptEntry, InterviewResult, ApplicationData, Contract, AdminSettings, AntiCheatReport } from './types';


const App: React.FC = () => {
  const { user, userRole, isLoginChoiceOpen, closeLoginChoice, isOnboardingOpen, openLoginChoice } = useAuth();
  
  const [route, setRoute] = useState<AppRoute>({ name: 'home' });
  const [jobs] = useState<Job[]>(JOBS);
  const [interviewResults, setInterviewResults] = useState<InterviewResult[]>(() => {
    const saved = localStorage.getItem('interviewResults');
    try {
      return saved ? JSON.parse(saved) : [];
    } catch (e) {
      console.error('Failed to parse interviewResults from localStorage', e);
      return [];
    }
  });
  
  // Persist interview results
  useEffect(() => {
    localStorage.setItem('interviewResults', JSON.stringify(interviewResults));
  }, [interviewResults]);

  const [contracts, setContracts] = useState<Contract[]>([]);
  const [isLoadingResult, setIsLoadingResult] = useState(false);
  const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
  const [adminSettings, setAdminSettings] = useState<AdminSettings>(() => {
    const defaultSettings: AdminSettings = {
        interviewer: {
            provider: 'gemini',
            systemPrompt: SYSTEM_PROMPT_TEMPLATE,
        },
        evaluation: {
            provider: 'gemini',
            openAI: {
                apiKey: '',
                model: 'gpt-4o',
            },
        },
    };
    try {
        const savedSettings = localStorage.getItem('adminSettings');
        if (!savedSettings) return defaultSettings;
        
        const parsed = JSON.parse(savedSettings);
        // Migration logic for old structure
        if (parsed.evaluationProvider) {
            return {
                interviewer: {
                    provider: 'gemini',
                    systemPrompt: parsed.interview?.systemPrompt || SYSTEM_PROMPT_TEMPLATE,
                },
                evaluation: {
                    provider: parsed.evaluationProvider,
                    openAI: {
                        apiKey: parsed.openAI?.apiKey || '',
                        model: parsed.openAI?.evaluationModel || 'gpt-4o',
                    },
                },
            };
        }
        // If it's already the new structure
        if (parsed.evaluation && parsed.interviewer) {
            return parsed;
        }
        return defaultSettings;
    } catch (error) {
        console.error("Could not parse admin settings from localStorage", error);
        return defaultSettings;
    }
  });

  useEffect(() => {
    if (!user) {
        // Public routes that don't need login
        const publicRoutes = ['home', 'explore', 'job', 'hirerLanding'];
        // If trying to access a protected route, just open login modal (don't redirect to home/landing)
        if (!publicRoutes.includes(route.name)) {
            openLoginChoice(); 
        }
    }
  }, [user, route.name, openLoginChoice]);

  const handleEndInterview = useCallback(async (
    transcript: TranscriptEntry[],
    recordingUrl: string,
    evaluation: any, // The summary object from pipeline
    antiCheatReport: AntiCheatReport
  ) => {
    if (route.name !== 'interviewLive') return;
  
    const { jobId, applicationData } = route;
    const job = jobs.find(j => j.id === jobId);
    if (!job) return;
  
    // The result is already generated by the pipeline, so we just map it and display it.
    // No more loading state needed here.
    setRoute({ name: 'interviewResult', resultIndex: interviewResults.length });
    setIsLoadingResult(false);
  
    const mappedEvaluation = {
      scores: {
        comms: evaluation.communication || 0,
        reasoning: evaluation.reasoning || 0,
        domain: evaluation.domainKnowledge || 0,
        overall: evaluation.overallScore || 0,
      },
      summary: evaluation.summaryText || "Evaluation summary not available.",
      // A simple way to get a short summary. Could be improved.
      shortSummary: evaluation.finalVerdict || evaluation.summaryText?.split('.')[0] || "No verdict.",
      detailedFeedback: evaluation.summaryText || "Detailed feedback not available.",
      strengths: evaluation.strengths || [],
      areasForImprovement: evaluation.areasForImprovement || [],
    };
  
    const newResult: InterviewResult = {
      job,
      date: new Date().toISOString(),
      application: applicationData,
      evaluation: mappedEvaluation,
      transcript,
      recordingUrl,
      antiCheatReport,
    };
  
    setInterviewResults(prev => [...prev, newResult]);
  
  }, [route, jobs, interviewResults.length]);

  const handleHire = (resultIndex: number, hourlyRate: number) => {
    if (contracts.some(c => c.resultIndex === resultIndex)) return;
    const newContract: Contract = {
      id: contracts.length + 1,
      resultIndex,
      status: 'Awaiting Funding',
      hourlyRate,
      escrowAmount: 0,
      hoursLogged: 0,
    };
    setContracts(prev => [...prev, newContract]);
  };
  
  const handleFund = (contractId: number, amount: number) => {
    setContracts(prev => prev.map(c => c.id === contractId ? { ...c, status: 'Active', escrowAmount: c.escrowAmount + amount } : c));
  };
  
  const handleRelease = (contractId: number) => {
    setContracts(prev => prev.map(c => c.id === contractId ? { ...c, status: 'Completed', escrowAmount: 0 } : c));
  };

  const handleDomainExpertComplete = (expertData: any) => {
    console.log("Domain Expert data submitted:", expertData);
    alert("Thank you for your submission! We will review your information and get back to you.");
    setRoute({ name: 'home' }); 
  };
  
  const handleSaveAdminSettings = (settings: AdminSettings) => {
    try {
        localStorage.setItem('adminSettings', JSON.stringify(settings));
        setAdminSettings(settings);
        alert('Admin settings saved successfully!');
        setRoute({ name: 'home' });
    } catch (error) {
        console.error("Could not save admin settings to localStorage", error);
        alert('Failed to save settings.');
    }
  };

  const renderContent = () => {
    // Hirers have a different home page
    if (userRole === 'hirer' && route.name === 'home') {
      return <HirerDashboardPage results={interviewResults} contracts={contracts} onHire={handleHire} onFund={handleFund} onRelease={handleRelease} setRoute={setRoute} />;
    }
    
    switch (route.name) {
      case 'home': return <HomePage setRoute={setRoute} />;
      case 'explore': return <ExplorePage jobs={jobs} setRoute={setRoute} />;
      case 'job': return <JobPage job={jobs.find(j => j.id === route.id)!} setRoute={setRoute} />;
      case 'apply': return <ApplyPage job={jobs.find(j => j.id === route.jobId)!} setRoute={setRoute} />;
      case 'prep': return <DeviceCheckPage job={jobs.find(j => j.id === route.jobId)!} applicationData={route.applicationData} setRoute={setRoute} />;
      case 'interviewLive': return <InterviewScreen job={jobs.find(j => j.id === route.jobId)!} applicationData={route.applicationData} onEnd={handleEndInterview} />;
      case 'interviewResult': return <InterviewResultPage result={interviewResults[route.resultIndex]} isLoading={isLoadingResult} setRoute={setRoute} />;
      case 'candidateDashboard': return <CandidateDashboardPage results={interviewResults} contracts={contracts} setRoute={setRoute} />;
      case 'hirerDashboard': return <HirerDashboardPage results={interviewResults} contracts={contracts} onHire={handleHire} onFund={handleFund} onRelease={handleRelease} setRoute={setRoute} />;
      case 'hirerLanding': return <HirerLandingPage setRoute={setRoute} />;
      case 'profile': return <ProfilePage />;
      case 'earnings': return <EarningsPage setRoute={setRoute} />;
      case 'referrals': return <ReferralsPage setRoute={setRoute} />;
      case 'domainExpert': return <DomainExpertPage job={jobs.find(j => j.id === route.jobId)!} applicationData={route.applicationData} onComplete={handleDomainExpertComplete} setRoute={setRoute} />;
      case 'settings': return <SettingsPage />;
      case 'admin': return <AdminPage settings={adminSettings} onSave={handleSaveAdminSettings} results={interviewResults} />;
      default: return <div>Not Found</div>;
    }
  };

  // PUBLIC VIEW (not logged in)
  if (!user) {
    // Check if trying to access protected route - show minimal background with login modal
    const isProtectedRoute = !['home', 'explore', 'job', 'hirerLanding'].includes(route.name);
    
    return (
        <div className="bg-neutral-950 text-neutral-100 font-sans min-h-screen">
            {isProtectedRoute ? (
                // Protected route - show minimal dark background (no landing page)
                <div className="min-h-screen flex items-center justify-center">
                    <div className="text-center">
                        <h1 className="text-2xl font-bold mb-4">Wind AI</h1>
                        <p className="text-neutral-400">Пожалуйста, войдите для продолжения</p>
                    </div>
                </div>
            ) : route.name === 'home' ? (
                // Landing Page for visitors
                <LandingPage setRoute={setRoute} />
            ) : route.name === 'hirerLanding' ? (
                // Landing Page for hirers
                <HirerLandingPage setRoute={setRoute} />
            ) : route.name === 'explore' ? (
                // Public job listing
                <main className="p-4 sm:p-6 lg:p-8">
                    <div className="mx-auto max-w-6xl">
                        <ExplorePage jobs={jobs} setRoute={setRoute} />
                    </div>
                </main>
            ) : route.name === 'job' ? (
                // Public job details
                <main className="p-4 sm:p-6 lg:p-8">
                    <div className="mx-auto max-w-6xl">
                        <JobPage job={jobs.find(j => j.id === route.id)!} setRoute={setRoute} />
                    </div>
                </main>
            ) : null}
            <LoginModal isOpen={isLoginChoiceOpen} onClose={closeLoginChoice} />
            <OnboardingModal isOpen={isOnboardingOpen} onClose={closeLoginChoice} />
        </div>
    );
  }

  // LOGGED IN VIEW
  return (
    <>
      <LoggedInLayout setRoute={setRoute} openSearchModal={() => setIsSearchModalOpen(true)}>
        {renderContent()}
      </LoggedInLayout>
      <SearchModal isOpen={isSearchModalOpen} onClose={() => setIsSearchModalOpen(false)} jobs={jobs} setRoute={setRoute} />
    </>
  );
};

export default App;
